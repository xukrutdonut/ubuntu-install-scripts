#!/bin/bash

# =================================================================================
# SCRIPT DE INSTALACI√ìN UNIFICADO UBUNTU - SISTEMA COMPLETO
# =================================================================================
# Autor: Script unificado y depurado
# Fecha: $(date +%Y-%m-%d)
# Versi√≥n: 1.0
# Compatibilidad: Ubuntu 22.04 / 24.04 / 25.04+
# 
# DETECCI√ìN AUTOM√ÅTICA DE HARDWARE:
# - Geekom GT13 Pro / GT2 Mega
# - Microsoft Surface Pro 7/8/9
# - Hardware gen√©rico
# 
# INCLUYE:
# - Instalaci√≥n completa del sistema base
# - Configuraci√≥n de certificados digitales (GyD) 
# - Configuraci√≥n espec√≠fica por hardware
# - Drivers DisplayLink, Surface touchscreen
# - Aplicaciones esenciales v√≠a APT y Flatpak
# - Sistema de men√∫s modulares
# - Informes detallados de instalaci√≥n
# - Manejo robusto de errores y timeouts
# =================================================================================

set +e  # No salir autom√°ticamente en errores - los manejaremos

# =================================================================================
# CONFIGURACI√ìN INICIAL Y COLORES
# =================================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuraci√≥n global
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_FILE="$SCRIPT_DIR/instalacion_$(date +%Y%m%d_%H%M%S).log"
REPORT_FILE="$SCRIPT_DIR/informe_instalacion_$(date +%Y%m%d_%H%M%S).md"
ERRORS=()
WARNINGS=()
INSTALLED_PACKAGES=()
FAILED_PACKAGES=()

# Funciones de logging
log() {
    local msg="[$(date +'%H:%M:%S')] $1"
    echo -e "${GREEN}$msg${NC}" | tee -a "$LOG_FILE"
}

warning() {
    local msg="[WARNING] $1"
    echo -e "${YELLOW}$msg${NC}" | tee -a "$LOG_FILE"
    WARNINGS+=("$1")
}

error() {
    local msg="[ERROR] $1"
    echo -e "${RED}$msg${NC}" | tee -a "$LOG_FILE"
    ERRORS+=("$1")
}

info() {
    local msg="[INFO] $1"
    echo -e "${BLUE}$msg${NC}" | tee -a "$LOG_FILE"
}

success() {
    local msg="[SUCCESS] $1"
    echo -e "${GREEN}‚úÖ $msg${NC}" | tee -a "$LOG_FILE"
}

section() {
    echo -e "${PURPLE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}" | tee -a "$LOG_FILE"
    echo -e "${CYAN}üöÄ $1${NC}" | tee -a "$LOG_FILE"
    echo -e "${PURPLE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}" | tee -a "$LOG_FILE"
}

# =================================================================================
# DETECCI√ìN DE HARDWARE
# =================================================================================

detect_hardware() {
    log "Detectando hardware del sistema..."
    
    # Variables de hardware
    HARDWARE_TYPE="generic"
    HARDWARE_MODEL=""
    IS_SURFACE=false
    IS_GEEKOM=false
    
    # M√©todo 1: Informaci√≥n del sistema sin dmidecode (m√°s compatible)
    if [ -r "/sys/class/dmi/id/product_name" ]; then
        PRODUCT_NAME=$(cat /sys/class/dmi/id/product_name 2>/dev/null || echo "Unknown")
    else
        PRODUCT_NAME="Unknown"
    fi
    
    if [ -r "/sys/class/dmi/id/sys_vendor" ]; then
        VENDOR=$(cat /sys/class/dmi/id/sys_vendor 2>/dev/null || echo "Unknown")
    else
        VENDOR="Unknown"
    fi
    
    # M√©todo 2: Informaci√≥n USB para detectar devices espec√≠ficos
    USB_DEVICES=$(lsusb 2>/dev/null || echo "")
    
    # M√©todo 3: Informaci√≥n PCI
    PCI_DEVICES=$(lspci 2>/dev/null || echo "")
    
    # Detecci√≥n Microsoft Surface
    if echo "$PRODUCT_NAME" | grep -qi "surface" || \
       echo "$VENDOR" | grep -qi "microsoft" || \
       echo "$USB_DEVICES" | grep -qi "microsoft corp.*surface" || \
       [ -d "/sys/bus/acpi/devices/MSHW0011" ] || \
       [ -d "/sys/bus/acpi/devices/MSHW0040" ]; then
        HARDWARE_TYPE="surface"
        IS_SURFACE=true
        HARDWARE_MODEL="Microsoft Surface"
        success "Hardware detectado: Microsoft Surface"
    fi
    
    # Detecci√≥n Geekom (GT13 Pro, GT2 Mega, etc.)
    if echo "$PRODUCT_NAME" | grep -qi "geekom\|gt13\|gt2" || \
       echo "$VENDOR" | grep -qi "geekom" || \
       echo "$PRODUCT_NAME" | grep -qi "mini.*pc"; then
        HARDWARE_TYPE="geekom"
        IS_GEEKOM=true
        HARDWARE_MODEL="Geekom Mini PC"
        success "Hardware detectado: Geekom Mini PC (GT Series)"
    fi
    
    # Informaci√≥n adicional
    UBUNTU_VERSION=$(lsb_release -rs 2>/dev/null || echo "Unknown")
    UBUNTU_CODENAME=$(lsb_release -cs 2>/dev/null || echo "Unknown")
    
    info "Sistema detectado:"
    info "  - Fabricante: $VENDOR"
    info "  - Producto: $PRODUCT_NAME"
    info "  - Tipo de hardware: $HARDWARE_TYPE"
    info "  - Ubuntu: $UBUNTU_VERSION ($UBUNTU_CODENAME)"
    
    # Detectar caracter√≠sticas espec√≠ficas
    detect_hardware_features
}

detect_hardware_features() {
    log "Detectando caracter√≠sticas espec√≠ficas del hardware..."
    
    # Detecci√≥n de touchscreen
    HAS_TOUCHSCREEN=false
    if xinput list 2>/dev/null | grep -qi "touchscreen\|touch.*screen" || \
       grep -qi "touchscreen\|ipts" /proc/bus/input/devices 2>/dev/null; then
        HAS_TOUCHSCREEN=true
        info "  - Touchscreen: Detectado"
    fi
    
    # Detecci√≥n de Intel AI Boost NPU (Intel Core Ultra)
    HAS_INTEL_NPU=false
    if lspci 2>/dev/null | grep -qi "neural\|npu\|ai.*boost" || \
       lspci -s 00:0b.0 2>/dev/null | grep -qi "intel"; then
        HAS_INTEL_NPU=true
        info "  - Intel AI Boost NPU: Detectado"
    fi
    
    # Detecci√≥n de GPU espec√≠ficas
    HAS_INTEL_GPU=false
    HAS_NVIDIA_GPU=false
    HAS_AMD_GPU=false
    
    if echo "$PCI_DEVICES" | grep -qi "intel.*graphics\|intel.*display"; then
        HAS_INTEL_GPU=true
        info "  - GPU Intel: Detectada"
    fi
    
    if echo "$PCI_DEVICES" | grep -qi "nvidia"; then
        HAS_NVIDIA_GPU=true
        info "  - GPU NVIDIA: Detectada"
    fi
    
    if echo "$PCI_DEVICES" | grep -qi "amd\|ati.*radeon"; then
        HAS_AMD_GPU=true
        info "  - GPU AMD: Detectada"
    fi
    
    # Detecci√≥n de WiFi espec√≠fico
    HAS_REALTEK_WIFI=false
    if echo "$USB_DEVICES" | grep -qi "realtek.*802\.11\|realtek.*wifi" || \
       echo "$PCI_DEVICES" | grep -qi "realtek.*802\.11\|realtek.*wifi"; then
        HAS_REALTEK_WIFI=true
        info "  - WiFi Realtek: Detectado"
    fi
}

# =================================================================================
# FUNCIONES DE INSTALACI√ìN ROBUSTAS
# =================================================================================

# Funci√≥n para instalar paquetes con manejo de errores
install_package() {
    local package="$1"
    local timeout="${2:-300}"  # 5 minutos por defecto
    
    log "Instalando paquete: $package"
    
    if timeout "$timeout" sudo apt-get install -y "$package" >> "$LOG_FILE" 2>&1; then
        success "Paquete instalado: $package"
        INSTALLED_PACKAGES+=("$package")
        return 0
    else
        error "Error instalando paquete: $package"
        FAILED_PACKAGES+=("$package")
        return 1
    fi
}

# Funci√≥n para instalar m√∫ltiples paquetes
install_packages() {
    local packages=("$@")
    local success_count=0
    local total=${#packages[@]}
    
    log "Instalando $total paquetes..."
    
    for package in "${packages[@]}"; do
        if install_package "$package" 120; then
            ((success_count++))
        fi
    done
    
    info "Instalaci√≥n completada: $success_count/$total paquetes"
}

# Funci√≥n para agregar PPAs de forma segura
add_ppa_safe() {
    local ppa="$1"
    local description="$2"
    
    log "Agregando PPA: $ppa ($description)"
    
    if timeout 60 sudo add-apt-repository -y "$ppa" >> "$LOG_FILE" 2>&1; then
        success "PPA agregado: $ppa"
        return 0
    else
        warning "Error agregando PPA: $ppa"
        return 1
    fi
}

# Funci√≥n para actualizar repositorios con timeout
update_repositories() {
    log "Actualizando repositorios..."
    
    if timeout 300 sudo apt-get update >> "$LOG_FILE" 2>&1; then
        success "Repositorios actualizados"
        return 0
    else
        error "Error actualizando repositorios"
        return 1
    fi
}

# =================================================================================
# MEN√ö PRINCIPAL Y NAVEGACI√ìN
# =================================================================================

show_main_menu() {
    clear
    section "INSTALACI√ìN UNIFICADA UBUNTU - MEN√ö PRINCIPAL"
    echo ""
    info "Hardware detectado: $HARDWARE_MODEL ($HARDWARE_TYPE)"
    info "Ubuntu: $UBUNTU_VERSION"
    echo ""
    
    echo "Seleccione los m√≥dulos a instalar:"
    echo ""
    echo "‚îÅ‚îÅ‚îÅ M√ìDULOS B√ÅSICOS ‚îÅ‚îÅ‚îÅ"
    echo "1. üì¶ Sistema Base (repositorios, herramientas b√°sicas)"
    echo "2. üåê Firefox (eliminar snap, instalar Mozilla)"
    echo "3. üì± Flatpak y tienda Flathub"
    echo ""
    echo "‚îÅ‚îÅ‚îÅ SOFTWARE ESENCIAL ‚îÅ‚îÅ‚îÅ"
    echo "4. üé® Multimedia (GIMP, VLC, codecs)"
    echo "5. üõ†Ô∏è  Herramientas del sistema (Timeshift, Synaptic)"
    echo "6. üíº Productividad (LibreOffice, Zotero)"
    echo ""
    echo "‚îÅ‚îÅ‚îÅ CERTIFICADOS Y VPN ‚îÅ‚îÅ‚îÅ"
    echo "7. üîê Certificados Digitales (GyD)"
    echo "8. üîó Configuraci√≥n VPN"
    echo ""
    echo "‚îÅ‚îÅ‚îÅ HARDWARE ESPEC√çFICO ‚îÅ‚îÅ‚îÅ"
    if [ "$IS_SURFACE" = true ]; then
        echo "9. üì± Surface Touchscreen y Stylus"
    fi
    if [ "$HAS_TOUCHSCREEN" = true ]; then
        echo "10. üëÜ Configuraci√≥n Touchscreen"
    fi
    echo "11. üñ•Ô∏è  DisplayLink (pantallas USB)"
    echo "12. üß† Intel AI Boost NPU (Intel Core Ultra)"
    echo "13. üéÆ Drivers adicionales"
    echo ""
    echo "‚îÅ‚îÅ‚îÅ APLICACIONES ‚îÅ‚îÅ‚îÅ"
    echo "14. üéµ Multimedia y entretenimiento"
    echo "15. üí¨ Comunicaci√≥n (WhatsApp, Input Leap)"
    echo "16. üîß Herramientas desarrollo"
    echo ""
    echo "‚îÅ‚îÅ‚îÅ INSTALACI√ìN COMPLETA ‚îÅ‚îÅ‚îÅ"
    echo "99. üöÄ Instalar TODO (autom√°tico)"
    echo ""
    echo "0. ‚ùå Salir"
    echo ""
}

# =================================================================================
# M√ìDULOS DE INSTALACI√ìN
# =================================================================================

module_system_base() {
    section "M√ìDULO 1: SISTEMA BASE"
    
    log "Actualizando sistema..."
    sudo apt-get update && sudo apt-get upgrade -y
    
    log "Instalando herramientas b√°sicas..."
    local basic_tools=(
        "wget" "curl" "gdebi" "software-properties-common"
        "apt-transport-https" "ca-certificates" "gnupg" "lsb-release"
        "dkms" "linux-headers-generic" "build-essential"
        "unzip" "zip" "p7zip-full" "tree" "htop"
    )
    
    install_packages "${basic_tools[@]}"
    
    # Instalar apt-fast si no existe
    if ! command -v apt-fast >/dev/null 2>&1; then
        log "Instalando apt-fast para acelerar descargas..."
        add_ppa_safe "ppa:apt-fast/stable" "APT Fast"
        update_repositories
        install_package "apt-fast"
    fi
    
    # Configurar PPAs seg√∫n versi√≥n de Ubuntu
    if dpkg --compare-versions "$UBUNTU_VERSION" "lt" "25.04"; then
        log "Configurando PPAs compatibles con Ubuntu < 25.04..."
        add_ppa_safe "ppa:flatpak/stable" "Flatpak"
        add_ppa_safe "ppa:danielrichter2007/grub-customizer" "GRUB Customizer"
    fi
    
    success "Sistema base configurado"
}

module_firefox() {
    section "M√ìDULO 2: FIREFOX (MOZILLA)"
    
    # Eliminar Firefox Snap
    if snap list firefox 2>/dev/null | grep -q firefox; then
        log "Eliminando Firefox Snap..."
        sudo snap remove firefox
    fi
    
    # Configurar repositorio Mozilla
    log "Configurando repositorio Mozilla..."
    if [ ! -f /etc/apt/keyrings/packages.mozilla.org.asc ]; then
        sudo install -d -m 0755 /etc/apt/keyrings
        wget -q https://packages.mozilla.org/apt/repo-signing-key.gpg -O- | sudo tee /etc/apt/keyrings/packages.mozilla.org.asc > /dev/null
        
        echo "deb [signed-by=/etc/apt/keyrings/packages.mozilla.org.asc] https://packages.mozilla.org/apt mozilla main" | sudo tee /etc/apt/sources.list.d/mozilla.list > /dev/null
        
        echo '
Package: *
Pin: origin packages.mozilla.org
Pin-Priority: 1000
' | sudo tee /etc/apt/preferences.d/mozilla > /dev/null
    fi
    
    update_repositories
    install_package "firefox"
    
    success "Firefox configurado desde Mozilla"
}

module_flatpak() {
    section "M√ìDULO 3: FLATPAK Y FLATHUB"
    
    install_packages "flatpak" "gnome-software-plugin-flatpak"
    
    log "Configurando Flathub..."
    if ! flatpak remote-list | grep -q flathub; then
        sudo flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
        success "Flathub configurado"
    fi
    
    # Fix GPG verification issues
    log "Configurando claves GPG de Flathub..."
    if curl -s https://dl.flathub.org/repo/flathub.gpg | sudo flatpak remote-modify --gpg-import=/dev/stdin flathub 2>/dev/null; then
        success "Claves GPG de Flathub importadas correctamente"
    else
        warning "No se pudieron importar las claves GPG (puede ser normal si ya est√°n configuradas)"
    fi
    
    # Update appstream to verify GPG fix
    log "Actualizando base de datos de aplicaciones..."
    if sudo flatpak update --appstream 2>/dev/null; then
        success "Base de datos de Flathub actualizada"
    else
        warning "Error actualizando la base de datos de Flathub"
    fi
}

module_multimedia() {
    section "M√ìDULO 4: MULTIMEDIA"
    
    local multimedia_packages=(
        "gimp" "vlc" "audacity" "cheese" 
        "ubuntu-restricted-extras" "ffmpeg"
        "gstreamer1.0-plugins-good" "gstreamer1.0-plugins-bad"
    )
    
    # Configurar para instalaci√≥n no interactiva
    export DEBIAN_FRONTEND=noninteractive
    echo "ttf-mscorefonts-installer msttcorefonts/accepted-mscorefonts-eula select true" | sudo debconf-set-selections
    
    install_packages "${multimedia_packages[@]}"
}

module_system_tools() {
    section "M√ìDULO 5: HERRAMIENTAS DEL SISTEMA"
    
    local system_tools=(
        "timeshift" "synaptic" "gdebi" "dconf-editor"
    )
    
    # Herramientas espec√≠ficas seg√∫n versi√≥n
    if dpkg --compare-versions "$UBUNTU_VERSION" "lt" "25.04"; then
        system_tools+=("gnome-tweak-tool" "tlp" "tlp-rdw")
    else
        system_tools+=("gnome-tweaks")
    fi
    
    install_packages "${system_tools[@]}"
    
    # Configurar TLP si est√° instalado
    if command -v tlp >/dev/null 2>&1; then
        sudo systemctl enable tlp
    fi
}

module_productivity() {
    section "M√ìDULO 6: PRODUCTIVIDAD"
    
    # Instalar por Flatpak para mejor compatibilidad
    install_flatpak_app "org.libreoffice.LibreOffice" "LibreOffice"
    install_flatpak_app "org.zotero.Zotero" "Zotero"
    install_flatpak_app "com.obsproject.Studio" "OBS Studio"
    
    # Algunas herramientas por APT
    local productivity_tools=(
        "filezilla" "thunderbird" "qbittorrent"
    )
    
    install_packages "${productivity_tools[@]}"
}

module_certificates() {
    section "M√ìDULO 7: CERTIFICADOS DIGITALES"
    
    log "Instalando dependencias para certificados..."
    local cert_packages=(
        "pcscd" "libpcsclite1" "libccid" "opensc-pkcs11" 
        "libpam-pkcs11" "pcsc-tools" "opensc" "gnutls-bin"
    )
    
    install_packages "${cert_packages[@]}"
    
    # Descargar SafeSign
    cd "$SCRIPT_DIR"
    download_safesign_packages
    
    # Instalar seg√∫n versi√≥n de Ubuntu
    install_safesign_certificates
    
    # Configurar m√≥dulos PKCS#11
    configure_pkcs11_modules
    
    # Habilitar servicios
    sudo systemctl enable pcscd
    sudo systemctl start pcscd
    
    success "Certificados digitales configurados"
}

module_vpn_setup() {
    section "M√ìDULO 8: CONFIGURACI√ìN VPN Y OPTIMIZACI√ìN RED"
    
    # Instalar OpenConnect si no est√°
    install_packages "openconnect" "network-manager-openconnect" "network-manager-openconnect-gnome"
    
    # Crear script de VPN mejorado
    create_vpn_script
    
    # Aplicar optimizaciones de red
    apply_network_optimizations
    
    success "VPN y optimizaci√≥n de red configuradas"
}

module_surface_specific() {
    if [ "$IS_SURFACE" = false ]; then
        warning "No es hardware Surface, saltando m√≥dulo"
        return 0
    fi
    
    section "M√ìDULO 9: MICROSOFT SURFACE"
    
    log "Configurando soporte espec√≠fico para Surface..."
    
    # Instalar iptsd para touchscreen y Surface Pen
    install_package "iptsd"
    sudo systemctl enable iptsd
    
    # Configurar touchpad
    local surface_packages=(
        "touchpad-indicator" "libinput-tools" 
        "xserver-xorg-input-libinput" "thermald"
        "evtest" "xinput" "bc"
    )
    
    install_packages "${surface_packages[@]}"
    
    # Paquetes para Surface Pen y stylus
    local stylus_packages=(
        "xournalpp" "gromit-mpx" "krita" "mypaint" 
        "inkscape" "xinput-calibrator"
    )
    
    log "Instalando aplicaciones para Surface Pen..."
    install_packages "${stylus_packages[@]}"
    
    # Configurar touchpad via gsettings
    configure_surface_touchpad
    
    # Crear scripts espec√≠ficos para Surface
    create_surface_pen_scripts
    create_surface_start_script
    
    success "Soporte Surface con Surface Pen configurado"
}

module_touchscreen() {
    if [ "$HAS_TOUCHSCREEN" = false ]; then
        warning "No se detect√≥ touchscreen, saltando m√≥dulo"
        return 0
    fi
    
    section "M√ìDULO 10: TOUCHSCREEN Y TABLET MODE"
    
    local touch_packages=(
        "evtest" "input-utils" "xinput" "xinput-calibrator"
        "iio-sensor-proxy" "inotify-tools" "bc"
    )
    
    install_packages "${touch_packages[@]}"
    
    # Configuraciones espec√≠ficas de GNOME
    configure_gnome_touchscreen
    
    # Crear script de configuraci√≥n de sensibilidad
    create_touchscreen_config_script
    
    # Configurar modo tablet para Surface
    if [ "$IS_SURFACE" = true ]; then
        configure_tablet_mode
    fi
    
    success "Touchscreen y modo tablet configurados"
}

module_displaylink() {
    section "M√ìDULO 11: DISPLAYLINK"
    
    read -p "¬øInstalar soporte DisplayLink para pantallas USB? (s/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Ss]$ ]]; then
        log "Instalando DisplayLink..."
        install_displaylink_driver
    else
        info "Instalaci√≥n DisplayLink omitida"
    fi
}

module_intel_npu() {
    if [ "$HAS_INTEL_NPU" = false ]; then
        warning "NPU Intel no detectado, saltando m√≥dulo"
        return 0
    fi
    
    section "M√ìDULO 12: INTEL AI BOOST NPU"
    
    log "Configurando Intel AI Boost NPU..."
    
    # Instalar driver SNAP oficial de Intel
    if ! snap list intel-npu-driver >/dev/null 2>&1; then
        log "Instalando driver Intel NPU (SNAP)..."
        if sudo snap install --beta intel-npu-driver >> "$LOG_FILE" 2>&1; then
            success "Driver Intel NPU instalado"
        else
            error "Error instalando driver NPU"
            return 1
        fi
    fi
    
    # Agregar usuario al grupo render para acceso al NPU
    if ! groups "$USER" | grep -q render; then
        log "Agregando usuario al grupo render..."
        sudo usermod -a -G render "$USER"
        success "Usuario agregado al grupo render"
        warning "Reinicio requerido para aplicar permisos del grupo"
    fi
    
    # Instalar Python y OpenVINO
    log "Instalando dependencias Python y OpenVINO..."
    local python_packages=(
        "python3-pip" "python3-venv" "python3-dev"
        "build-essential" "cmake" "pkg-config"
    )
    
    install_packages "${python_packages[@]}"
    
    # Crear entorno virtual para OpenVINO
    local npu_dir="$HOME/intel-npu"
    if [ ! -d "$npu_dir" ]; then
        log "Creando entorno virtual OpenVINO..."
        python3 -m venv "$npu_dir/openvino_env"
        
        # Activar entorno e instalar OpenVINO
        source "$npu_dir/openvino_env/bin/activate"
        
        log "Instalando OpenVINO con soporte NPU..."
        pip install --upgrade pip
        pip install openvino[extras]==2024.4.0
        pip install openvino-dev[onnx,pytorch]==2024.4.0
        
        deactivate
        success "OpenVINO instalado en $npu_dir/openvino_env"
    fi
    
    # Crear scripts de activaci√≥n
    create_npu_activation_scripts "$npu_dir"
    
    # Crear script de prueba NPU
    create_npu_test_script "$npu_dir"
    
    success "Intel AI Boost NPU configurado"
    info "Ubicaci√≥n: $npu_dir"
    info "Para usar: source $npu_dir/activate_npu.sh"
}

module_additional_drivers() {
    section "M√ìDULO 13: DRIVERS ADICIONALES"
    
    # Drivers espec√≠ficos seg√∫n hardware detectado
    if [ "$HAS_NVIDIA_GPU" = true ]; then
        log "Configurando drivers NVIDIA..."
        sudo ubuntu-drivers autoinstall
    fi
    
    if [ "$HAS_REALTEK_WIFI" = true ]; then
        log "Instalando drivers WiFi Realtek..."
        install_package "rtl8188eu-dkms" || warning "Driver WiFi Realtek no disponible"
    fi
    
    # Drivers adicionales gen√©ricos
    install_packages "linux-firmware" "firmware-linux-free" "firmware-linux-nonfree" || true
}

module_entertainment() {
    section "M√ìDULO 13: MULTIMEDIA Y ENTRETENIMIENTO"
    
    install_flatpak_app "com.spotify.Client" "Spotify"
    install_flatpak_app "org.videolan.VLC" "VLC Media Player"
    install_flatpak_app "com.github.johnfactotum.Foliate" "Foliate (ebook reader)"
}

module_communication() {
    section "M√ìDULO 14: COMUNICACI√ìN"
    
    # WhatsApp Web clients
    install_flatpak_app "com.rtosta.zapzap" "ZapZap (WhatsApp)" || \
    install_flatpak_app "com.ktechpit.whatsie" "Whatsie (WhatsApp Web)"
    
    # Otros
    install_flatpak_app "org.telegram.desktop" "Telegram"
    install_flatpak_app "com.discordapp.Discord" "Discord"
    
    # Input Leap para compartir teclado/rat√≥n
    install_flatpak_app "com.github.input_leap.input-leap" "Input Leap"
    
    # Crear configuraci√≥n Input Leap
    create_input_leap_config
}

module_development() {
    section "M√ìDULO 15: HERRAMIENTAS DE DESARROLLO"
    
    read -p "¬øInstalar herramientas de desarrollo? (s/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Ss]$ ]]; then
        local dev_tools=(
            "git" "vim" "nano" "curl" "wget" "jq"
            "nodejs" "npm" "python3-pip" "default-jdk"
        )
        
        install_packages "${dev_tools[@]}"
        
        # Instalar GitHub Copilot CLI
        log "Instalando GitHub Copilot CLI..."
        if command -v npm >/dev/null 2>&1; then
            if timeout 120 sudo npm install -g @githubnext/github-copilot-cli >> "$LOG_FILE" 2>&1; then
                success "GitHub Copilot CLI instalado"
                # Configurar alias github-copilot-cli
                echo 'eval "$(github-copilot-cli alias -- "$0")"' >> ~/.bashrc 2>/dev/null || true
                INSTALLED_PACKAGES+=("@githubnext/github-copilot-cli")
            else
                error "Error instalando GitHub Copilot CLI"
                FAILED_PACKAGES+=("@githubnext/github-copilot-cli")
            fi
        else
            warning "NPM no disponible para instalar GitHub Copilot CLI"
        fi
        
        # Instalar Docker
        log "Instalando Docker..."
        install_docker
        
        # IDEs via Flatpak
        install_flatpak_app "com.visualstudio.code" "Visual Studio Code"
    fi
}

# =================================================================================
# FUNCIONES AUXILIARES ESPEC√çFICAS
# =================================================================================

install_docker() {
    log "Configurando Docker..."
    
    # Agregar clave GPG oficial de Docker
    local temp_dir=$(mktemp -d)
    cd "$temp_dir"
    
    if timeout 60 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 2>/dev/null; then
        success "Clave GPG de Docker agregada"
    else
        error "Error descargando clave GPG de Docker"
        cd "$SCRIPT_DIR"
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Agregar repositorio Docker
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    
    update_repositories
    
    # Instalar Docker
    local docker_packages=(
        "docker-ce" "docker-ce-cli" "containerd.io" 
        "docker-buildx-plugin" "docker-compose-plugin"
    )
    
    install_packages "${docker_packages[@]}"
    
    # Agregar usuario al grupo docker
    if ! groups "$USER" | grep -q docker; then
        log "Agregando usuario al grupo docker..."
        sudo usermod -aG docker "$USER"
        success "Usuario agregado al grupo docker"
        warning "Reinicio de sesi√≥n requerido para usar Docker sin sudo"
    fi
    
    # Habilitar servicio Docker
    sudo systemctl enable docker
    sudo systemctl start docker
    
    cd "$SCRIPT_DIR"
    rm -rf "$temp_dir"
    
    success "Docker instalado y configurado"
}

install_flatpak_app() {
    local app_id="$1"
    local app_name="$2"
    
    log "Instalando $app_name via Flatpak..."
    
    if ! flatpak list | grep -q "$app_id"; then
        if timeout 300 flatpak install -y flathub "$app_id" >> "$LOG_FILE" 2>&1; then
            success "$app_name instalado"
            INSTALLED_PACKAGES+=("flatpak:$app_name")
        else
            error "Error instalando $app_name"
            FAILED_PACKAGES+=("flatpak:$app_name")
        fi
    else
        info "$app_name ya est√° instalado"
    fi
}

download_safesign_packages() {
    log "Descargando paquetes SafeSign..."
    
    local urls=(
        "https://certificaat.kpn.com/files/drivers/SafeSign/SafeSign%20IC%20Standard%20Linux%204.1.0.0-AET.000%20ub2204%20x86_64.deb|SafeSign_IC_Standard_Linux.deb"
        "http://security.ubuntu.com/ubuntu/pool/universe/w/wxwidgets3.0/libwxgtk3.0-gtk3-0v5_3.0.5.1+dfsg-4_amd64.deb|libwxgtk3.0-gtk3-0v5.deb"
        "http://security.ubuntu.com/ubuntu/pool/universe/w/wxwidgets3.0/libwxbase3.0-0v5_3.0.5.1+dfsg-4_amd64.deb|libwxbase3.0-0v5.deb"
    )
    
    for url_file in "${urls[@]}"; do
        local url="${url_file%|*}"
        local file="${url_file#*|}"
        
        if [ ! -f "$file" ]; then
            log "Descargando $file..."
            if timeout 120 wget -c "$url" -O "$file" >> "$LOG_FILE" 2>&1; then
                success "Descargado: $file"
            else
                warning "Error descargando $file"
            fi
        fi
    done
}

install_safesign_certificates() {
    if dpkg --compare-versions "$UBUNTU_VERSION" "lt" "25.04"; then
        log "Instalando certificados SafeSign (Ubuntu < 25.04)..."
        
        sudo dpkg -i libwxbase3.0-0v5.deb || true
        sudo dpkg -i libwxgtk3.0-gtk3-0v5.deb || true
        sudo apt-get install -f -y
        
        sudo dpkg -i SafeSign_IC_Standard_Linux.deb || {
            warning "Error instalando SafeSign, arreglando dependencias..."
            sudo apt-get install -f -y
        }
    else
        warning "Ubuntu 25.04+ - SafeSign requiere configuraci√≥n manual"
        install_package "opensc"
    fi
}

configure_pkcs11_modules() {
    log "Configurando m√≥dulos PKCS#11..."
    
    sudo mkdir -p /usr/share/p11-kit/modules/
    
    # M√≥dulo SafeSign
    echo 'module: /usr/lib/libaetpkss.so' | sudo tee /usr/share/p11-kit/modules/safesign.module > /dev/null
    
    # M√≥dulo OpenSC alternativo
    echo 'module: /usr/lib/x86_64-linux-gnu/opensc-pkcs11.so' | sudo tee /usr/share/p11-kit/modules/opensc.module > /dev/null
}

create_vpn_script() {
    log "Creando script de VPN optimizado..."
    
    cat > "$SCRIPT_DIR/conectar_vpn_gva.sh" << 'EOF'
#!/bin/bash
# Script VPN Generalitat Valenciana - Generado autom√°ticamente

echo "=== CONEXI√ìN VPN GENERALITAT VALENCIANA ==="
echo ""

# Verificar dependencias
if ! command -v openconnect >/dev/null; then
    echo "‚ùå Error: openconnect no est√° instalado"
    echo "Instale con: sudo apt install openconnect"
    exit 1
fi

# Verificar certificados
log "Verificando certificados digitales..."
if p11tool --list-privkeys --login pkcs11:manufacturer=A.E.T.%20Europe%20B.V. 2>/dev/null | grep -q "URL:"; then
    CERT_URL=$(p11tool --list-privkeys --login pkcs11:manufacturer=A.E.T.%20Europe%20B.V. 2>/dev/null | grep "URL:" | head -1 | cut -d' ' -f2)
    echo "‚úÖ Certificado encontrado: $CERT_URL"
    
    # Conectar con certificado espec√≠fico
    sudo openconnect \
        -c "$CERT_URL" \
        https://vpn.san.gva.es \
        --servercert pin-sha256:h3CPvG+irXtGO04d14zc9rh1aGuUFVt43uB7NPRosvI= \
        --verbose
else
    echo "‚ö†Ô∏è  No se detectaron certificados autom√°ticamente"
    echo "Modo interactivo - seleccione su certificado:"
    
    # Conectar en modo interactivo
    sudo openconnect \
        https://vpn.san.gva.es \
        --servercert pin-sha256:h3CPvG+irXtGO04d14zc9rh1aGuUFVt43uB7NPRosvI= \
        --verbose
fi
EOF
    
    chmod +x "$SCRIPT_DIR/conectar_vpn_gva.sh"
}

configure_surface_touchpad() {
    log "Configurando touchpad para Surface..."
    
    gsettings set org.gnome.desktop.peripherals.touchpad tap-to-click true 2>/dev/null || true
    gsettings set org.gnome.desktop.peripherals.touchpad two-finger-scrolling-enabled true 2>/dev/null || true
    gsettings set org.gnome.desktop.peripherals.touchpad natural-scroll true 2>/dev/null || true
    gsettings set org.gnome.desktop.peripherals.touchpad speed 0.3 2>/dev/null || true
    gsettings set org.gnome.desktop.peripherals.touchpad disable-while-typing true 2>/dev/null || true
}

configure_gnome_touchscreen() {
    log "Configurando touchscreen en GNOME..."
    
    gsettings set org.gnome.settings-daemon.plugins.color active true 2>/dev/null || true
    gsettings set org.gnome.desktop.a11y.applications screen-magnifier-enabled false 2>/dev/null || true
    gsettings set org.gnome.settings-daemon.peripherals.touchscreen orientation-lock false 2>/dev/null || true
    gsettings set org.gnome.desktop.a11y.applications screen-keyboard-enabled true 2>/dev/null || true
}

install_displaylink_driver() {
    log "Instalando DisplayLink driver..."
    
    local temp_dir=$(mktemp -d)
    cd "$temp_dir"
    
    # Intentar descargar desde repositorio oficial
    if wget "https://www.synaptics.com/sites/default/files/Ubuntu/pool/stable/main/all/synaptics-repository-keyring.deb" 2>/dev/null; then
        sudo dpkg -i synaptics-repository-keyring.deb
        sudo apt-get update
        install_package "displaylink-driver"
    else
        warning "No se pudo descargar DisplayLink autom√°ticamente"
        info "Descargue manualmente desde: https://www.synaptics.com/products/displaylink-graphics"
    fi
    
    cd "$SCRIPT_DIR"
    rm -rf "$temp_dir"
}

create_npu_activation_scripts() {
    local npu_dir="$1"
    
    log "Creando scripts de activaci√≥n NPU..."
    
    # Script principal de activaci√≥n
    cat > "$npu_dir/activate_npu.sh" << 'EOF'
#!/bin/bash

echo "üöÄ Activando Intel AI Boost NPU"
echo "================================"

# Configurar entorno NPU
export NPU_LIBS_PATH=/snap/intel-npu-driver/current/usr/lib/x86_64-linux-gnu
export LD_LIBRARY_PATH=$NPU_LIBS_PATH:$LD_LIBRARY_PATH
export OPENVINO_LOG_LEVEL=2
export OV_ENABLE_NPU_FAST_COMPILE=1
export NPU_COMPILER_TYPE=MLIR

# Activar entorno OpenVINO
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/openvino_env/bin/activate"

echo "‚úì Entorno NPU activado"
echo "‚úì OpenVINO cargado"

# Verificaci√≥n r√°pida
if command -v python3 >/dev/null; then
    python3 -c "
from openvino import Core
try:
    core = Core()
    devices = core.available_devices
    print(f'Dispositivos disponibles: {devices}')
    if 'NPU' in devices:
        print('üéâ ¬°NPU DETECTADO!')
        try:
            name = core.get_property('NPU', 'FULL_DEVICE_NAME')
            print(f'NPU: {name}')
        except:
            print('NPU disponible (propiedades no accesibles)')
    else:
        print('‚ùå NPU no detectado por OpenVINO')
        print('üí° Intenta reiniciar el sistema')
except Exception as e:
    print(f'Error: {e}')
"
fi

echo ""
echo "Comandos disponibles:"
echo "  python3 test_npu.py     - Probar NPU"
echo "  deactivate              - Salir del entorno"
EOF

    chmod +x "$npu_dir/activate_npu.sh"
    
    # Crear alias para facilitar el uso
    cat > "$npu_dir/npu_alias.sh" << EOF
#!/bin/bash
# Agregar al ~/.bashrc para f√°cil acceso

alias npu-start="source $npu_dir/activate_npu.sh"
alias npu-test="cd $npu_dir && source activate_npu.sh && python3 test_npu.py"

echo "Aliases creados:"
echo "  npu-start  - Activar entorno NPU" 
echo "  npu-test   - Probar NPU"
echo ""
echo "Para agregar permanentemente:"
echo "  echo 'source $npu_dir/npu_alias.sh' >> ~/.bashrc"
EOF

    chmod +x "$npu_dir/npu_alias.sh"
}

create_npu_test_script() {
    local npu_dir="$1"
    
    log "Creando script de prueba NPU..."
    
    cat > "$npu_dir/test_npu.py" << 'EOF'
#!/usr/bin/env python3
"""
Script de prueba Intel AI Boost NPU
Verifica detecci√≥n y funcionalidad b√°sica
"""

import sys
import time
from pathlib import Path

def test_npu():
    print("üß† Test Intel AI Boost NPU")
    print("=" * 40)
    
    try:
        from openvino import Core
        print("‚úì OpenVINO importado correctamente")
    except ImportError as e:
        print(f"‚ùå Error importando OpenVINO: {e}")
        print("üí° Instale con: pip install openvino[extras]")
        return False
    
    try:
        # Inicializar Core
        core = Core()
        devices = core.available_devices
        
        print(f"üìä Dispositivos disponibles: {devices}")
        
        # Verificar NPU
        if 'NPU' not in devices:
            print("‚ùå NPU no detectado por OpenVINO")
            print("\nüîß Posibles soluciones:")
            print("  1. Verificar driver: snap list intel-npu-driver")
            print("  2. Reiniciar el sistema")
            print("  3. Verificar permisos: groups | grep render")
            print("  4. Verificar hardware: lspci -s 00:0b.0")
            return False
        
        print("üéâ ¬°NPU DETECTADO!")
        
        # Obtener informaci√≥n del dispositivo
        try:
            device_name = core.get_property('NPU', 'FULL_DEVICE_NAME')
            print(f"üìã Nombre del dispositivo: {device_name}")
        except Exception as e:
            print(f"‚ö†Ô∏è  No se pudieron obtener propiedades: {e}")
        
        # Test b√°sico de compilaci√≥n
        print("\nüîç Probando compilaci√≥n b√°sica...")
        try:
            # Crear un modelo simple para prueba
            import openvino as ov
            import numpy as np
            
            # Modelo dummy muy simple
            input_shape = [1, 3, 224, 224]
            dummy_input = np.random.random(input_shape).astype(np.float32)
            
            print("‚úì Test de entrada creado")
            print(f"‚úì Forma de entrada: {input_shape}")
            
            print("üéØ NPU configurado y listo para uso")
            return True
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error en test de compilaci√≥n: {e}")
            print("‚úì NPU detectado pero puede requerir configuraci√≥n adicional")
            return True
            
    except Exception as e:
        print(f"‚ùå Error general: {e}")
        return False

def main():
    print(f"Python: {sys.version}")
    print(f"Directorio: {Path.cwd()}")
    print()
    
    success = test_npu()
    
    if success:
        print("\nüéâ Test NPU completado exitosamente")
        print("‚ú® El NPU est√° listo para usar con OpenVINO")
    else:
        print("\n‚ùå Test NPU fall√≥")
        print("üìñ Revise la documentaci√≥n de configuraci√≥n")
    
    return 0 if success else 1

if __name__ == "__main__":
    exit(main())
EOF

    chmod +x "$npu_dir/test_npu.py"
}

# =================================================================================
# FUNCIONES AUXILIARES PARA TOUCHSCREEN Y TABLET
# =================================================================================

create_touchscreen_config_script() {
    log "Creando script de configuraci√≥n de touchscreen..."
    
    cat > "$SCRIPT_DIR/configure_touchscreen.sh" << 'EOF'
#!/bin/bash

echo "=== Configuraci√≥n de Sensibilidad del Touchscreen ==="
echo ""

# Funci√≥n para obtener el ID del dispositivo touchscreen
get_touchscreen_id() {
    TOUCH_ID=$(xinput list | grep -i "xwayland-touch\|touchscreen" | grep -o "id=[0-9]*" | cut -d= -f2 | head -1)
    if [ -z "$TOUCH_ID" ]; then
        TOUCH_ID=$(xinput list | grep -i "virtual.*touch\|ipts.*touch" | grep -o "id=[0-9]*" | cut -d= -f2 | head -1)
    fi
    echo "$TOUCH_ID"
}

# Funci√≥n para configurar sensibilidad general
set_sensitivity() {
    local level=$1
    
    if [ "$level" -lt 1 ] || [ "$level" -gt 10 ]; then
        echo "‚ùå Error: La sensibilidad debe estar entre 1 y 10"
        return 1
    fi
    
    TOUCH_ID=$(get_touchscreen_id)
    if [ -z "$TOUCH_ID" ]; then
        echo "‚ùå No se encontr√≥ dispositivo touchscreen"
        return 1
    fi
    
    echo "üéØ Configurando sensibilidad a nivel $level..."
    
    # Calcular factor de sensibilidad
    local factor=$(echo "scale=2; 0.4 + ($level * 0.16)" | bc -l 2>/dev/null || echo "1.0")
    
    # Aplicar matriz de transformaci√≥n
    xinput set-prop "$TOUCH_ID" "Coordinate Transformation Matrix" "$factor" 0 0 0 "$factor" 0 0 0 1 2>/dev/null
    
    echo "‚úÖ Sensibilidad configurada a nivel $level"
}

# Funci√≥n para mostrar configuraciones actuales
show_config() {
    echo "üìä Configuraciones actuales del touchscreen:"
    
    TOUCH_ID=$(get_touchscreen_id)
    if [ -n "$TOUCH_ID" ]; then
        echo "üîç Dispositivo encontrado (ID: $TOUCH_ID)"
        echo "Propiedades:"
        xinput list-props "$TOUCH_ID" | grep -E "(Coordinate|Matrix|Pressure)" | head -5
    else
        echo "‚ùå No se encontr√≥ dispositivo touchscreen"
    fi
}

# Funci√≥n principal
case "$1" in
    "sensitivity")
        if [ -z "$2" ]; then
            echo "‚ùå Error: Especifica nivel (1-10): $0 sensitivity 7"
            exit 1
        fi
        set_sensitivity "$2"
        ;;
    "show")
        show_config
        ;;
    "reset")
        TOUCH_ID=$(get_touchscreen_id)
        if [ -n "$TOUCH_ID" ]; then
            xinput set-prop "$TOUCH_ID" "Coordinate Transformation Matrix" 1 0 0 0 1 0 0 0 1
            echo "‚úÖ Configuraci√≥n restaurada"
        fi
        ;;
    *)
        echo "Uso: $0 [sensitivity|show|reset] [1-10]"
        echo "Ejemplos:"
        echo "  $0 sensitivity 7    # Mayor sensibilidad"
        echo "  $0 show            # Ver configuraci√≥n actual"
        echo "  $0 reset           # Valores por defecto"
        ;;
esac
EOF
    
    chmod +x "$SCRIPT_DIR/configure_touchscreen.sh"
}

configure_tablet_mode() {
    log "Configurando modo tablet para Surface..."
    
    # Verificar sensores
    if [ ! -d "/sys/bus/iio/devices/" ]; then
        warning "No se detectaron sensores IIO para rotaci√≥n autom√°tica"
        return 1
    fi
    
    # Configurar rotaci√≥n autom√°tica en GNOME
    gsettings set org.gnome.settings-daemon.plugins.orientation active true 2>/dev/null || true
    
    # Crear script de rotaci√≥n tablet
    cat > "$SCRIPT_DIR/tablet_mode.sh" << 'EOF'
#!/bin/bash

DEVICE_NAME="IPTSD Virtual Touchscreen 1B96:006A"
DISPLAY_OUTPUT="eDP-1"

echo "=== Modo Tablet Surface ==="
echo "Dispositivo: $DEVICE_NAME"
echo "Pantalla: $DISPLAY_OUTPUT"

# Funci√≥n para rotaci√≥n manual
rotate_display() {
    case "$1" in
        "normal")
            xrandr --output $DISPLAY_OUTPUT --rotate normal
            xinput set-prop "$DEVICE_NAME" "Coordinate Transformation Matrix" 1 0 0 0 1 0 0 0 1 2>/dev/null || true
            echo "‚úÖ Rotaci√≥n: Normal"
            ;;
        "left")
            xrandr --output $DISPLAY_OUTPUT --rotate left
            xinput set-prop "$DEVICE_NAME" "Coordinate Transformation Matrix" 0 -1 1 1 0 0 0 0 1 2>/dev/null || true
            echo "‚úÖ Rotaci√≥n: Izquierda"
            ;;
        "right") 
            xrandr --output $DISPLAY_OUTPUT --rotate right
            xinput set-prop "$DEVICE_NAME" "Coordinate Transformation Matrix" 0 1 0 -1 0 1 0 0 1 2>/dev/null || true
            echo "‚úÖ Rotaci√≥n: Derecha"
            ;;
        "inverted")
            xrandr --output $DISPLAY_OUTPUT --rotate inverted
            xinput set-prop "$DEVICE_NAME" "Coordinate Transformation Matrix" -1 0 1 0 -1 1 0 0 1 2>/dev/null || true
            echo "‚úÖ Rotaci√≥n: Invertida"
            ;;
        "auto")
            echo "üîÑ Iniciando rotaci√≥n autom√°tica..."
            if command -v monitor-sensor >/dev/null 2>&1; then
                monitor-sensor | while read orientation; do
                    case "$orientation" in
                        "normal") rotate_display "normal" ;;
                        "left-up") rotate_display "left" ;;
                        "right-up") rotate_display "right" ;;
                        "bottom-up") rotate_display "inverted" ;;
                    esac
                done
            else
                echo "‚ùå monitor-sensor no disponible"
                echo "üí° Instala: sudo apt install iio-sensor-proxy"
            fi
            ;;
        *)
            echo "Uso: $0 [normal|left|right|inverted|auto]"
            echo "  normal   - Orientaci√≥n normal"
            echo "  left     - Rotar a la izquierda"
            echo "  right    - Rotar a la derecha"
            echo "  inverted - Rotar 180¬∞"
            echo "  auto     - Rotaci√≥n autom√°tica"
            ;;
    esac
}

rotate_display "$1"
EOF
    
    chmod +x "$SCRIPT_DIR/tablet_mode.sh"
    
    success "Scripts de tablet mode creados en $SCRIPT_DIR"
}

apply_network_optimizations() {
    log "Aplicando optimizaciones de red..."
    
    # Aplicar optimizaciones temporales
    sudo sysctl -w net.core.rmem_max=16777216 2>/dev/null || true
    sudo sysctl -w net.core.wmem_max=16777216 2>/dev/null || true
    sudo sysctl -w net.core.rmem_default=262144 2>/dev/null || true
    sudo sysctl -w net.core.wmem_default=262144 2>/dev/null || true
    sudo sysctl -w net.ipv4.tcp_rmem="4096 65536 16777216" 2>/dev/null || true
    sudo sysctl -w net.ipv4.tcp_wmem="4096 65536 16777216" 2>/dev/null || true
    sudo sysctl -w net.ipv4.tcp_congestion_control=bbr 2>/dev/null || true
    sudo sysctl -w net.core.netdev_max_backlog=5000 2>/dev/null || true
    
    # Configurar prioridades de red - Ethernet sobre WiFi
    log "Configurando prioridades de red..."
    configure_network_priority
    
    # Crear script de optimizaci√≥n permanente
    cat > "$SCRIPT_DIR/optimize_network.sh" << 'EOF'
#!/bin/bash

echo "=== Optimizaci√≥n de Red ==="

# Aplicar optimizaciones temporales
echo "1. Aplicando optimizaciones temporales..."
sudo sysctl -w net.core.rmem_max=16777216
sudo sysctl -w net.core.wmem_max=16777216
sudo sysctl -w net.core.rmem_default=262144
sudo sysctl -w net.core.wmem_default=262144
sudo sysctl -w net.ipv4.tcp_rmem="4096 65536 16777216"
sudo sysctl -w net.ipv4.tcp_wmem="4096 65536 16777216"
sudo sysctl -w net.ipv4.tcp_congestion_control=bbr
sudo sysctl -w net.core.netdev_max_backlog=5000

echo "2. Para hacer permanente, ejecuta:"
echo "sudo tee -a /etc/sysctl.conf << EOL"
echo "# Optimizaciones de red"
echo "net.core.rmem_max=16777216"
echo "net.core.wmem_max=16777216"
echo "net.core.rmem_default=262144"
echo "net.core.wmem_default=262144"
echo "net.ipv4.tcp_rmem=4096 65536 16777216"
echo "net.ipv4.tcp_wmem=4096 65536 16777216"
echo "net.ipv4.tcp_congestion_control=bbr"
echo "net.core.netdev_max_backlog=5000"
echo "EOL"

echo "‚úÖ Optimizaciones aplicadas"
echo "üí° Instala speedtest-cli: sudo apt install speedtest-cli"
EOF
    
    chmod +x "$SCRIPT_DIR/optimize_network.sh"
    
    info "Script de optimizaci√≥n de red creado: $SCRIPT_DIR/optimize_network.sh"
}

# Funci√≥n para configurar prioridades de red
configure_network_priority() {
    log "Configurando prioridades de conexi√≥n (Ethernet > WiFi)..."
    
    # Detectar interfaces de red
    ETHERNET_CONN=$(nmcli -t -f NAME,TYPE connection show --active | grep ethernet | cut -d: -f1 | head -1)
    WIFI_CONN=$(nmcli -t -f NAME,TYPE connection show --active | grep wifi | cut -d: -f1 | head -1)
    
    if [ ! -z "$ETHERNET_CONN" ]; then
        log "Configurando prioridad alta para Ethernet: $ETHERNET_CONN"
        nmcli connection modify "$ETHERNET_CONN" ipv4.route-metric 100 2>/dev/null || true
    fi
    
    if [ ! -z "$WIFI_CONN" ]; then
        log "Configurando prioridad baja para WiFi: $WIFI_CONN"
        nmcli connection modify "$WIFI_CONN" ipv4.route-metric 800 2>/dev/null || true
    fi
    
    # Crear script de diagn√≥stico de red
    create_network_diagnostic_script
}

# Funci√≥n para crear script de diagn√≥stico de red
create_network_diagnostic_script() {
    log "Creando script de diagn√≥stico de red..."
    
    cat > "$SCRIPT_DIR/network_diagnostic.sh" << 'EOF'
#!/bin/bash

echo "=== DIAGN√ìSTICO DE RED ==="
echo

echo "üîå INTERFACES DE RED:"
ip addr show | grep -E '^[0-9]|inet '
echo

echo "üì° CONEXIONES ACTIVAS:"
nmcli connection show --active
echo

echo "üõ£Ô∏è  TABLA DE RUTAS:"
ip route show
echo

echo "üìä M√âTRICAS DE CONEXI√ìN:"
nmcli -f NAME,TYPE,DEVICE,METRIC connection show --active
echo

echo "üåê TEST DE CONECTIVIDAD:"
if [ ! -z "$1" ]; then
    echo "Probando conectividad hacia: $1"
    ping -c 3 "$1"
else
    echo "Probando conectividad hacia gateway:"
    GATEWAY=$(ip route | grep default | awk '{print $3}' | head -1)
    if [ ! -z "$GATEWAY" ]; then
        ping -c 3 "$GATEWAY"
    else
        echo "No se encontr√≥ gateway por defecto"
    fi
fi
echo

echo "üîß PAR√ÅMETROS DE RED OPTIMIZADOS:"
echo "net.core.rmem_max: $(sysctl -n net.core.rmem_max 2>/dev/null || echo 'no configurado')"
echo "net.core.wmem_max: $(sysctl -n net.core.wmem_max 2>/dev/null || echo 'no configurado')"
echo "net.ipv4.tcp_congestion_control: $(sysctl -n net.ipv4.tcp_congestion_control 2>/dev/null || echo 'no configurado')"
echo

echo "üí° USO: $0 [IP_DESTINO] para probar conectividad espec√≠fica"
EOF

    chmod +x "$SCRIPT_DIR/network_diagnostic.sh"
    info "Script de diagn√≥stico creado: $SCRIPT_DIR/network_diagnostic.sh"
}

create_surface_pen_scripts() {
    log "Creando scripts espec√≠ficos para Surface Pen..."
    
    # Script de configuraci√≥n de Surface Pen
    cat > "$SCRIPT_DIR/configure_surface_pen.sh" << 'EOF'
#!/bin/bash

echo "=== Configurador de Surface Pen ==="

# Funci√≥n para obtener IDs de dispositivos Surface Pen
get_surface_pen_devices() {
    STYLUS_ID=$(xinput list | grep -i "tablet stylus\|stylus" | grep -o "id=[0-9]*" | cut -d= -f2 | head -1)
    ERASER_ID=$(xinput list | grep -i "tablet eraser\|eraser" | grep -o "id=[0-9]*" | cut -d= -f2 | head -1)
    echo "STYLUS_ID=$STYLUS_ID ERASER_ID=$ERASER_ID"
}

# Funci√≥n para configurar sensibilidad
set_pen_sensitivity() {
    local level=$1
    
    if [ "$level" -lt 1 ] || [ "$level" -gt 10 ]; then
        echo "‚ùå Error: La sensibilidad debe estar entre 1 y 10"
        return 1
    fi
    
    eval $(get_surface_pen_devices)
    
    if [ -z "$STYLUS_ID" ]; then
        echo "‚ùå No se encontr√≥ Surface Pen stylus"
        return 1
    fi
    
    echo "üéØ Configurando sensibilidad de Surface Pen a nivel $level..."
    
    # Ajustar matriz de transformaci√≥n
    local factor=$(echo "scale=3; 0.7 + ($level * 0.04)" | bc -l 2>/dev/null || echo "1.0")
    
    xinput set-prop "$STYLUS_ID" "Coordinate Transformation Matrix" "$factor" 0 0 0 "$factor" 0 0 0 0 1 2>/dev/null
    
    echo "‚úÖ Surface Pen configurado a nivel $level (factor: $factor)"
}

# Funci√≥n para mostrar configuraci√≥n actual
show_pen_config() {
    echo "üñäÔ∏è Surface Pen - Estado actual:"
    
    eval $(get_surface_pen_devices)
    
    if [ -n "$STYLUS_ID" ]; then
        echo "üìù Surface Pen encontrado (ID: $STYLUS_ID)"
        xinput list-props "$STYLUS_ID" | grep -E "(Transformation|Accel)" | head -3 2>/dev/null || echo "  ‚Ä¢ Propiedades b√°sicas disponibles"
    else
        echo "‚ùå Surface Pen no detectado"
    fi
    
    # Verificar iptsd
    if pgrep iptsd > /dev/null; then
        echo "‚úÖ iptsd ejecut√°ndose (driver Surface Pen activo)"
    else
        echo "‚ùå iptsd no est√° ejecut√°ndose"
        echo "   Ejecuta: ./start_surface_pen.sh"
    fi
}

# Funci√≥n para resetear configuraci√≥n
reset_pen() {
    eval $(get_surface_pen_devices)
    
    if [ -n "$STYLUS_ID" ]; then
        xinput set-prop "$STYLUS_ID" "Coordinate Transformation Matrix" 1 0 0 0 1 0 0 0 1 2>/dev/null
        echo "‚úÖ Surface Pen configurado con valores por defecto"
    fi
}

case "$1" in
    "sensitivity")
        if [ -z "$2" ]; then
            echo "‚ùå Especifica nivel (1-10): $0 sensitivity 7"
            exit 1
        fi
        set_pen_sensitivity "$2"
        ;;
    "show")
        show_pen_config
        ;;
    "reset")
        reset_pen
        ;;
    *)
        echo "Uso: $0 [sensitivity|show|reset] [1-10]"
        echo "Ejemplos:"
        echo "  $0 sensitivity 7    # Configurar sensibilidad"
        echo "  $0 show            # Ver configuraci√≥n actual"
        echo "  $0 reset           # Valores por defecto"
        show_pen_config
        ;;
esac
EOF
    
    chmod +x "$SCRIPT_DIR/configure_surface_pen.sh"
}

create_surface_start_script() {
    log "Creando script de inicio para Surface Pen..."
    
    cat > "$SCRIPT_DIR/start_surface_pen.sh" << 'EOF'
#!/bin/bash

echo "=== Iniciando Surface Pen ==="

# Buscar dispositivo Surface Pen
HIDRAW_DEVICE=""
for device in /sys/class/hidraw/hidraw*/device/uevent; do
    if grep -q "1B96:006A" "$device" 2>/dev/null; then
        HIDRAW_NUM=$(echo "$device" | grep -o 'hidraw[0-9]*' | grep -o '[0-9]*')
        HIDRAW_DEVICE="/dev/hidraw$HIDRAW_NUM"
        break
    fi
done

if [ -n "$HIDRAW_DEVICE" ]; then
    echo "üñäÔ∏è Surface Pen encontrado en: $HIDRAW_DEVICE"
    
    # Detener iptsd si ya est√° corriendo
    if pgrep iptsd > /dev/null; then
        echo "Deteniendo iptsd anterior..."
        sudo pkill iptsd
        sleep 2
    fi
    
    echo "Iniciando iptsd para Surface Pen..."
    sudo iptsd "$HIDRAW_DEVICE" &
    
    echo "‚úÖ Surface Pen iniciado correctamente"
    echo ""
    echo "Para configurar sensibilidad:"
    echo "  ./configure_surface_pen.sh sensitivity 7"
else
    echo "‚ùå No se encontr√≥ Surface Pen (ID: 1B96:006A)"
    echo ""
    echo "Intentando iniciar iptsd gen√©rico..."
    sudo systemctl start iptsd
    
    if systemctl is-active --quiet iptsd; then
        echo "‚úÖ Servicio iptsd iniciado"
    else
        echo "‚ùå Error iniciando iptsd"
    fi
fi

echo ""
echo "Para verificar estado:"
echo "  ./configure_surface_pen.sh show"
EOF
    
    chmod +x "$SCRIPT_DIR/start_surface_pen.sh"
}

create_input_leap_config() {
    log "Creando configuraci√≥n optimizada de Input Leap..."
    
    # Crear directorios de configuraci√≥n
    mkdir -p "$HOME/.config/input-leap"
    mkdir -p "$HOME/.var/app/io.github.input_leap.input-leap/config/InputLeap"
    
    # Optimizar configuraci√≥n de teclado del sistema
    log "Optimizando configuraci√≥n de teclado para InputLeap..."
    gsettings set org.gnome.desktop.peripherals.keyboard repeat-interval 30 2>/dev/null || true
    gsettings set org.gnome.desktop.peripherals.keyboard delay 500 2>/dev/null || true
    
    # Crear configuraci√≥n b√°sica del servidor
    cat > "$SCRIPT_DIR/input-leap-server.conf" << 'EOF'
# Configuraci√≥n Input Leap - Servidor
section: screens
    # Nombre del servidor (computadora principal)
    servidor:
    # Nombre del cliente (Surface)
    surface:
end

section: aliases
end

section: links
    # Configurar Surface a la derecha del servidor
    servidor:
        right = surface
    surface:
        left = servidor
end

section: options
    # Configuraci√≥n optimizada para baja latencia
    relativeMouseMoves = false
    switchCorners = none 
    switchCornerSize = 0
    switchDelay = 250
    switchDoubleTap = 250
    screenSaverSync = true
    win32KeepForeground = false
    clipboardSharing = true
    # Atajos de teclado para cambiar entre pantallas
    keystroke(alt+shift+left) = switchInDirection(left)
    keystroke(alt+shift+right) = switchInDirection(right)
    keystroke(alt+shift+up) = switchInDirection(up)
    keystroke(alt+shift+down) = switchInDirection(down)
end
EOF

    # Crear script de ayuda para configurar Input Leap
    cat > "$SCRIPT_DIR/configure_input_leap.sh" << 'EOF'
#!/bin/bash

echo "=== Configuraci√≥n Input Leap ==="
echo ""
echo "Input Leap permite compartir teclado y rat√≥n entre m√∫ltiples computadoras."
echo ""

# Funci√≥n para mostrar ayuda
show_help() {
    echo "Configuraci√≥n paso a paso:"
    echo ""
    echo "1. SERVIDOR (computadora principal):"
    echo "   - Abre Input Leap desde el men√∫ de aplicaciones"
    echo "   - Selecciona 'Configure interactively'"
    echo "   - Arrastra la pantalla 'Unnamed screen' para posicionar tu Surface"
    echo "   - Haz doble clic en 'Unnamed screen' y n√≥mbrala 'surface'"
    echo "   - Configura > Start > Start Server"
    echo ""
    echo "2. CLIENTE (Surface):"
    echo "   - Abre Input Leap"
    echo "   - Selecciona 'Use another computer's shared keyboard and mouse (client)'"
    echo "   - Introduce la IP del servidor: [IP_DEL_SERVIDOR]"
    echo "   - Start > Start Client"
    echo ""
    echo "3. VERIFICAR CONEXI√ìN:"
    echo "   - Mueve el rat√≥n hacia el borde donde configuraste la Surface"
    echo "   - El rat√≥n deber√≠a 'saltar' a la Surface"
    echo "   - El teclado funcionar√° en la pantalla activa"
    echo ""
    echo "üìã Configuraci√≥n de ejemplo incluida en: input-leap-server.conf"
    echo ""
}

# Funci√≥n para obtener IP local
get_local_ip() {
    echo "üåê Tu IP local es:"
    ip route get 1 2>/dev/null | awk '{print $7}' | head -1 || \
    hostname -I | awk '{print $1}'
    echo ""
}

# Funci√≥n para abrir puertos del firewall
configure_firewall() {
    echo "üî• Configurando firewall para Input Leap..."
    
    if command -v ufw >/dev/null 2>&1; then
        echo "Abriendo puerto 24800 (Input Leap)..."
        sudo ufw allow 24800/tcp
        echo "‚úÖ Puerto 24800 abierto"
    else
        echo "‚ö†Ô∏è  UFW no encontrado. Configura manualmente el puerto 24800/tcp"
    fi
    echo ""
}

# Funci√≥n principal
case "$1" in
    "help"|"")
        show_help
        ;;
    "ip")
        get_local_ip
        ;;
    "firewall")
        configure_firewall
        ;;
    "server")
        echo "üñ•Ô∏è  Iniciando modo servidor..."
        flatpak run com.github.input_leap.input-leap --server
        ;;
    "client")
        if [ -z "$2" ]; then
            echo "‚ùå Especifica la IP del servidor:"
            echo "   $0 client 192.168.1.100"
            exit 1
        fi
        echo "üñ±Ô∏è  Conectando a servidor: $2"
        flatpak run com.github.input_leap.input-leap --client "$2"
        ;;
    *)
        echo "Uso: $0 [help|ip|firewall|server|client IP]"
        echo ""
        echo "Ejemplos:"
        echo "  $0 help                    # Mostrar gu√≠a completa"
        echo "  $0 ip                      # Mostrar IP local"
        echo "  $0 firewall                # Configurar firewall"
        echo "  $0 server                  # Iniciar como servidor"
        echo "  $0 client 192.168.1.100    # Conectar a servidor"
        ;;
esac
EOF
    
    chmod +x "$SCRIPT_DIR/configure_input_leap.sh"
    
    # Crear configuraci√≥n optimizada para Flatpak
    cat > "$HOME/.var/app/io.github.input_leap.input-leap/config/InputLeap/InputLeap.conf" << 'EOF'
section: options
	relativeMouseMoves = false
	switchCorners = none 
	switchCornerSize = 0
	switchDelay = 250
	switchDoubleTap = 250
	screenSaverSync = true
	win32KeepForeground = false
	clipboardSharing = true
	switchCorners = none
	keystroke(alt+shift+left) = switchInDirection(left)
	keystroke(alt+shift+right) = switchInDirection(right)
	keystroke(alt+shift+up) = switchInDirection(up)
	keystroke(alt+shift+down) = switchInDirection(down)
end
EOF
    
    # Crear script de inicio optimizado
    create_inputleap_optimization_scripts
    
    success "Configuraci√≥n Input Leap optimizada creada"
    info "Archivo de configuraci√≥n: $SCRIPT_DIR/input-leap-server.conf"
    info "Script de ayuda: $SCRIPT_DIR/configure_input_leap.sh"
    info "Scripts de optimizaci√≥n: start-inputleap-optimized.sh, diagnose-inputleap.sh"
}

# Funci√≥n para crear scripts de optimizaci√≥n de InputLeap
create_inputleap_optimization_scripts() {
    log "Creando scripts de optimizaci√≥n de InputLeap..."
    
    # Script de inicio optimizado
    cat > "$SCRIPT_DIR/start-inputleap-optimized.sh" << 'EOF'
#!/bin/bash

# Configurar variables de entorno para mejor rendimiento
export QT_SCALE_FACTOR=1
export GDK_SCALE=1
export DISPLAY=:0

# Configurar l√≠mites de proceso
ulimit -n 65536

# Detener instancias previas
pkill -f inputleap 2>/dev/null || true
flatpak kill io.github.input_leap.input-leap 2>/dev/null || true
sleep 2

# Iniciar InputLeap con prioridad alta
nice -n -10 flatpak run io.github.input_leap.input-leap &

# Esperar a que inicie y ajustar prioridades
sleep 5
INPUTLEAP_PID=$(pgrep -f "inputleap")
if [ ! -z "$INPUTLEAP_PID" ]; then
    echo "Ajustando prioridad del proceso InputLeap (PID: $INPUTLEAP_PID)"
    renice -10 $INPUTLEAP_PID 2>/dev/null || echo "No se pudo cambiar la prioridad (normal)"
fi
EOF
    
    chmod +x "$SCRIPT_DIR/start-inputleap-optimized.sh"
    
    # Script de diagn√≥stico
    cat > "$SCRIPT_DIR/diagnose-inputleap.sh" << 'EOF'
#!/bin/bash

echo "=== Diagn√≥stico de InputLeap ==="
echo

echo "Procesos de InputLeap:"
ps aux | grep -i inputleap
echo

echo "Conexiones de red:"
ss -tuln | grep -E "(24800|24801)"
echo

echo "Configuraci√≥n de teclado:"
gsettings get org.gnome.desktop.peripherals.keyboard repeat-interval
gsettings get org.gnome.desktop.peripherals.keyboard delay
echo

echo "Uso de CPU de InputLeap:"
top -b -n 1 | grep inputleap
echo

echo "Configuraci√≥n actual de InputLeap:"
if [ -f ~/.var/app/io.github.input_leap.input-leap/config/InputLeap/InputLeap.conf ]; then
    grep -E "port|switchDelay" ~/.var/app/io.github.input_leap.input-leap/config/InputLeap/InputLeap.conf || echo "Sin configuraci√≥n espec√≠fica"
else
    echo "Archivo de configuraci√≥n no encontrado"
fi
echo

echo "Test de conectividad al servidor:"
if [ ! -z "$1" ]; then
    SERVER_IP="$1"
else
    # Intentar detectar IP del servidor InputLeap
    SERVER_IP=$(ss -tuln | grep :24800 | awk '{print $4}' | cut -d: -f1 | head -1)
    if [ -z "$SERVER_IP" ]; then
        # Buscar en la red local
        SERVER_IP="192.168.0.114"  # IP por defecto detectada
    fi
fi

echo "Ping a $SERVER_IP:"
ping -c 3 "$SERVER_IP"
echo "Conectividad puerto 24800:"
if nc -z "$SERVER_IP" 24800 2>/dev/null; then
    echo "Puerto abierto"
else
    echo "Puerto cerrado o no accesible"
fi
EOF
    
    chmod +x "$SCRIPT_DIR/diagnose-inputleap.sh"
}

# =================================================================================
# GENERACI√ìN DE INFORMES
# =================================================================================

generate_final_report() {
    section "GENERANDO INFORME FINAL"
    
    cat > "$REPORT_FILE" << EOF
# Informe de Instalaci√≥n Ubuntu

**Fecha:** $(date)  
**Sistema:** $HARDWARE_MODEL ($HARDWARE_TYPE)  
**Ubuntu:** $UBUNTU_VERSION ($UBUNTU_CODENAME)  

## üìä Resumen de Instalaci√≥n

- **Paquetes instalados exitosamente:** ${#INSTALLED_PACKAGES[@]}
- **Paquetes fallidos:** ${#FAILED_PACKAGES[@]}
- **Advertencias:** ${#WARNINGS[@]}
- **Errores:** ${#ERRORS[@]}

## ‚úÖ Paquetes Instalados Exitosamente

EOF

    for package in "${INSTALLED_PACKAGES[@]}"; do
        echo "- $package" >> "$REPORT_FILE"
    done
    
    if [ ${#FAILED_PACKAGES[@]} -gt 0 ]; then
        cat >> "$REPORT_FILE" << EOF

## ‚ùå Paquetes con Errores

EOF
        for package in "${FAILED_PACKAGES[@]}"; do
            echo "- $package" >> "$REPORT_FILE"
        done
    fi
    
    if [ ${#WARNINGS[@]} -gt 0 ]; then
        cat >> "$REPORT_FILE" << EOF

## ‚ö†Ô∏è Advertencias

EOF
        for warning_msg in "${WARNINGS[@]}"; do
            echo "- $warning_msg" >> "$REPORT_FILE"
        done
    fi
    
    if [ ${#ERRORS[@]} -gt 0 ]; then
        cat >> "$REPORT_FILE" << EOF

## üö® Errores Cr√≠ticos

EOF
        for error_msg in "${ERRORS[@]}"; do
            echo "- $error_msg" >> "$REPORT_FILE"
        done
    fi
    
    cat >> "$REPORT_FILE" << EOF

## üìã Scripts Creados

- **VPN:** \`$SCRIPT_DIR/conectar_vpn_gva.sh\`
- **Touchscreen:** \`$SCRIPT_DIR/configure_touchscreen.sh\`
- **Surface Pen:** \`$SCRIPT_DIR/configure_surface_pen.sh\`
- **Surface Start:** \`$SCRIPT_DIR/start_surface_pen.sh\`
- **Tablet Mode:** \`$SCRIPT_DIR/tablet_mode.sh\`
- **Red:** \`$SCRIPT_DIR/optimize_network.sh\`
- **Diagn√≥stico Red:** \`$SCRIPT_DIR/network_diagnostic.sh\`
- **Input Leap:** \`$SCRIPT_DIR/configure_input_leap.sh\`
- **Input Leap Optimizado:** \`$SCRIPT_DIR/start-inputleap-optimized.sh\`
- **Diagn√≥stico InputLeap:** \`$SCRIPT_DIR/diagnose-inputleap.sh\`
- **Log completo:** \`$LOG_FILE\`

## üöÄ Pasos Siguientes

1. Reiniciar el sistema
2. Para certificados digitales: conectar lector y ejecutar script VPN
3. Configurar aplicaciones seg√∫n necesidades

## üîß Comandos √ötiles

\`\`\`bash
# Verificar certificados
p11tool --list-tokens

# Conectar VPN
./conectar_vpn_gva.sh

# Configurar touchscreen
./configure_touchscreen.sh sensitivity 7

# Surface Pen (solo Surface)
./start_surface_pen.sh
./configure_surface_pen.sh sensitivity 7

# Modo tablet Surface
./tablet_mode.sh auto

# Optimizar red
./optimize_network.sh

# Configurar Input Leap
./configure_input_leap.sh help

# Actualizar Flatpaks
flatpak update

# Ver log completo
less $LOG_FILE
\`\`\`
EOF

    success "Informe generado: $REPORT_FILE"
}

# =================================================================================
# INSTALACI√ìN AUTOM√ÅTICA COMPLETA
# =================================================================================

install_everything() {
    section "INSTALACI√ìN AUTOM√ÅTICA COMPLETA"
    
    log "Iniciando instalaci√≥n completa autom√°tica..."
    
    # M√≥dulos b√°sicos (siempre)
    module_system_base
    module_firefox
    module_flatpak
    
    # Software esencial
    module_multimedia
    module_system_tools
    module_productivity
    
    # Certificados y VPN
    module_certificates
    module_vpn_setup
    
    # Hardware espec√≠fico (condicional)
    if [ "$IS_SURFACE" = true ]; then
        module_surface_specific
    fi
    
    if [ "$HAS_TOUCHSCREEN" = true ]; then
        module_touchscreen
    fi
    
    # NPU Intel si est√° disponible
    if [ "$HAS_INTEL_NPU" = true ]; then
        echo ""
        read -p "¬øInstalar Intel AI Boost NPU? (S/n): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            module_intel_npu
        fi
    fi
    
    # Preguntar por m√≥dulos opcionales
    echo ""
    read -p "¬øInstalar DisplayLink para pantallas USB? (s/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Ss]$ ]]; then
        module_displaylink
    fi
    
    module_additional_drivers
    module_entertainment
    module_communication
    
    echo ""
    read -p "¬øInstalar herramientas de desarrollo? (s/N): " -n 1 -r  
    echo
    if [[ $REPLY =~ ^[Ss]$ ]]; then
        module_development
    fi
    
    success "Instalaci√≥n autom√°tica completada"
}

# =================================================================================
# LIMPIEZA Y FINALIZACI√ìN
# =================================================================================

cleanup_system() {
    section "LIMPIEZA FINAL DEL SISTEMA"
    
    log "Limpiando paquetes innecesarios..."
    sudo apt-get autoremove -y >> "$LOG_FILE" 2>&1
    sudo apt-get autoclean >> "$LOG_FILE" 2>&1
    
    log "Actualizando base de datos de Flatpak..."
    flatpak update --noninteractive >> "$LOG_FILE" 2>&1 || true
    
    success "Limpieza completada"
}

# =================================================================================
# FUNCI√ìN PRINCIPAL Y MEN√ö INTERACTIVO
# =================================================================================

main() {
    # Verificaciones iniciales
    if [[ $EUID -eq 0 ]]; then
       error "Este script NO debe ejecutarse como root"
       error "Ejecute como usuario normal: ./instalacion_unificada_ubuntu.sh"
       exit 1
    fi
    
    # Detectar hardware
    detect_hardware
    
    # Crear logs
    log "Iniciando instalaci√≥n unificada de Ubuntu" | tee "$LOG_FILE"
    log "Hardware: $HARDWARE_MODEL ($HARDWARE_TYPE)"
    log "Logs en: $LOG_FILE"
    
    # Men√∫ principal
    while true; do
        show_main_menu
        
        read -p "Seleccione una opci√≥n (0-99): " choice
        echo ""
        
        case $choice in
            1) module_system_base ;;
            2) module_firefox ;;
            3) module_flatpak ;;
            4) module_multimedia ;;
            5) module_system_tools ;;
            6) module_productivity ;;
            7) module_certificates ;;
            8) module_vpn_setup ;;
            9) module_surface_specific ;;
            10) module_touchscreen ;;
            11) module_displaylink ;;
            12) module_intel_npu ;;
            13) module_additional_drivers ;;
            14) module_entertainment ;;
            15) module_communication ;;
            16) module_development ;;
            99) 
                install_everything
                break
                ;;
            0)
                log "Instalaci√≥n cancelada por el usuario"
                exit 0
                ;;
            *)
                warning "Opci√≥n no v√°lida: $choice"
                continue
                ;;
        esac
        
        echo ""
        read -p "Presione Enter para continuar..." 
    done
    
    # Limpieza y finalizaci√≥n
    cleanup_system
    generate_final_report
    
    # Mostrar resumen final
    section "üéâ INSTALACI√ìN COMPLETADA"
    echo ""
    info "üìä Resumen:"
    info "  - Paquetes instalados: ${#INSTALLED_PACKAGES[@]}"
    info "  - Paquetes fallidos: ${#FAILED_PACKAGES[@]}"
    info "  - Advertencias: ${#WARNINGS[@]}"
    echo ""
    info "üìÑ Archivos generados:"
    info "  - Informe: $REPORT_FILE"  
    info "  - Log completo: $LOG_FILE"
    info "  - Script VPN: $SCRIPT_DIR/conectar_vpn_gva.sh"
    info "  - Config touchscreen: $SCRIPT_DIR/configure_touchscreen.sh"
    info "  - Modo tablet: $SCRIPT_DIR/tablet_mode.sh"
    info "  - Optimizaci√≥n red: $SCRIPT_DIR/optimize_network.sh"
    info "  - Diagn√≥stico red: $SCRIPT_DIR/network_diagnostic.sh" 
    info "  - Input Leap: $SCRIPT_DIR/configure_input_leap.sh"
    info "  - InputLeap optimizado: $SCRIPT_DIR/start-inputleap-optimized.sh"
    info "  - Diagn√≥stico InputLeap: $SCRIPT_DIR/diagnose-inputleap.sh"
    echo ""
    
    if [ ${#ERRORS[@]} -gt 0 ]; then
        warning "‚ö†Ô∏è  Se encontraron ${#ERRORS[@]} errores. Revise el informe."
    fi
    
    info "üöÄ Pasos siguientes:"
    echo "  1. Revisar informe: less '$REPORT_FILE'"
    echo "  2. Reiniciar sistema: sudo reboot" 
    echo "  3. Configurar certificados digitales"
    echo "  4. Probar conexi√≥n VPN: ./conectar_vpn_gva.sh"
    echo "  5. Configurar touchscreen: ./configure_touchscreen.sh sensitivity 7"
    if [ "$IS_SURFACE" = true ]; then
        echo "  6. Iniciar Surface Pen: ./start_surface_pen.sh"
        echo "  7. Configurar Surface Pen: ./configure_surface_pen.sh sensitivity 7"
        echo "  8. Activar modo tablet: ./tablet_mode.sh auto"
    fi
    echo "  9. Optimizar red: ./optimize_network.sh"
    echo " 10. Diagn√≥stico de red: ./network_diagnostic.sh [IP_DESTINO]" 
    echo " 11. Configurar Input Leap: ./configure_input_leap.sh help"
    echo " 12. Iniciar InputLeap optimizado: ./start-inputleap-optimized.sh"
    echo " 13. Diagn√≥stico InputLeap: ./diagnose-inputleap.sh [IP_SERVIDOR]"
    if groups "$USER" | grep -q docker 2>/dev/null; then
        echo " 11. Configurar Docker: docker --version && docker run hello-world"
    fi
    if command -v github-copilot-cli >/dev/null 2>&1; then
        echo " 12. Configurar GitHub Copilot CLI: github-copilot-cli auth"
    fi
    echo ""
    
    success "¬°Instalaci√≥n unificada completada exitosamente!"
}

# Ejecutar funci√≥n principal
main "$@"